package oksana;

public abstract class TestFiles {

    public static String getValidTestFile() {
        return ";.386 ;for EAX and others\n"
                + "Data segment; use32 ;for 32-bit adress	\n"
                + "	Var1 db rrr\n"
                + "	Var12 db -1h\n"
                + "	Var2 dw 012ABh	\n"
                + "	Var22 dw -0FFh\n"
                + "	Var3 dd 0AB12CD34h\n"
                + "	Var32 dd 01h\n"
                + "	VarStr db 'Hello!'\n"
                + "Data ends\n"
                + "\n"
                + "rrr = 23h\n"
                + "\n"
                + "Code segment; use32 ;for 32-bit adress\n"
                + ";assume ds:Data, cs:Code\n"
                + "begin:\n"
                + "	\n"
                + "	if rrr\n"
                + "		cmpsd\n"
                + "	endif\n"
                + "	\n"
                + "	;if 0\n"
                + "		;push mem\n"
                + "		push dword ptr [eax + eax]\n"
                + "		push dword ptr [eax + ecx]\n"
                + "		push dword ptr [ecx + eax]\n"
                + "		push dword ptr [eax + edi]\n"
                + "		push dword ptr [edi + edi]\n"
                + "		\n"
                + "		push dword ptr Var1[eax + eax]\n"
                + "		push dword ptr Var2[eax + ecx]\n"
                + "		push dword ptr [ecx + ebp]\n"
                + "		push Var3[eax + esi]\n"
                + "		push dword ptr [edi + esp]	\n"
                + "	\n"
                + "		;adc reg , reg\n"
                + "		adc al, al\n"
                + "		adc al, cl\n"
                + "		adc cl, al\n"
                + "		\n"
                + "		adc eax, eax\n"
                + "		adc eax, ecx\n"
                + "		adc ecx, eax\n"
                + "	\n"
                + "		;cmp reg , mem\n"
                + "		cmp al, byte ptr [eax + eax]\n"
                + "		cmp al, byte ptr [eax + ecx]\n"
                + "		cmp al, byte ptr [ecx + eax]\n"
                + "		cmp dh, byte ptr [edi + edi]	\n"
                + "		\n"
                + "		cmp al, Var1[eax + eax]\n"
                + "		cmp dh, Var1[edi + edi]\n"
                + "		\n"
                + "		cmp eax, dword ptr [eax + eax]\n"
                + "		cmp eax, dword ptr [eax + ecx]\n"
                + "		cmp eax, dword ptr [ecx + eax]\n"
                + "		cmp edi, dword ptr [edi + edi]\n"
                + "		\n"
                + "		cmp eax, Var3[eax + eax]\n"
                + "		cmp esi, Var3[edi + edi]\n"
                + "		\n"
                + "		;and mem , reg\n"
                + "		and byte ptr [eax + eax], al\n"
                + "		and byte ptr [eax + ecx], al\n"
                + "		and byte ptr [ecx + eax], al\n"
                + "		and byte ptr [edi + edi], dh\n"
                + "		\n"
                + "		and Var1[eax + eax], al\n"
                + "		and Var1[edi + edi], dh\n"
                + "		\n"
                + "		and dword ptr [eax + eax], eax\n"
                + "		and dword ptr [eax + ecx], eax\n"
                + "		and dword ptr [ecx + eax], eax\n"
                + "		and dword ptr [edi + edi], edi\n"
                + "		\n"
                + "		and Var3[eax + eax], eax\n"
                + "		and Var3[edi + edi], esi\n"
                + "			\n"
                + "		;shr reg , const (id)\n"
                + "		shr al, 1\n"
                + "		shr cl, 1\n"
                + "		shr bh, 1\n"
                + "		\n"
                + "		shr al, 2\n"
                + "		shr cl, 2\n"
                + "		shr bh, 2\n"
                + "		\n"
                + "		shr eax, 1\n"
                + "		shr ecx, 1\n"
                + "		shr ebp, 1\n"
                + "		\n"
                + "		shr eax, 2\n"
                + "		shr ecx, 2\n"
                + "		shr ebp, 2\n"
                + "		\n"
                + "		;or mem , const (id)\n"
                + "		or byte ptr [eax + eax], 1\n"
                + "		or byte ptr [eax + ecx], 1\n"
                + "		or byte ptr [ecx + eax], 1\n"
                + "		or byte ptr [edi + edi], 1		\n"
                + "		\n"
                + "		or Var1[eax + eax], 1\n"
                + "		or Var1[edi + edi], 1		\n"
                + "		\n"
                + "		or dword ptr [eax + eax], 1\n"
                + "		or dword ptr [eax + ecx], 1\n"
                + "		or dword ptr [ecx + eax], 1\n"
                + "		or dword ptr [edi + edi], 1\n"
                + "		\n"
                + "		or Var3[eax + eax], 1\n"
                + "		or Var3[edi + edi], 1\n"
                + "		\n"
                + "		or dword ptr [eax + eax], 111h\n"
                + "		or dword ptr [eax + ecx], 111h\n"
                + "		or dword ptr [ecx + eax], 111h\n"
                + "		or dword ptr [edi + edi], 111h\n"
                + "		\n"
                + "		or Var3[eax + eax], 111h\n"
                + "		or Var3[edi + edi], 111h\n"
                + "	\n"
                + "Code ends\n"
                + "end begin";
    }

}
